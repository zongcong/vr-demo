import{d as z,w as on,t as xt,V as wt,e as Oe,L as Z,g as Et,f as rn,z as G,B as N,N as cn,y as an,R as Se,K as Ke,j as ln,M as fn,O as un,i as ot,U as pn,X as Te,S as dn,P as hn,A as mn,W as yn,Y as xn,q as wn,c as ne,v as _e,D as bn,H as gn}from"./three.module-c1ebb987.js";import{G as An,m as Tn}from"./GLTFLoader-ada4c348.js";import{O as Bn}from"./OrbitControls-a045cf16.js";import{d as Pn,r as Mn,o as Sn,c as _n,a as vn}from"./index-c4a4b524.js";const Bt=new z;function q(s,e,t,n,i,a){const r=2*Math.PI*i/4,c=Math.max(a-2*i,0),o=Math.PI/4;Bt.copy(e),Bt[n]=0,Bt.normalize();const p=.5*r/(r+c),f=1-Bt.angleTo(s)/o;return Math.sign(Bt[t])===1?f*p:c/(r+c)+p+p*(1-f)}class Cn extends on{constructor(e=1,t=1,n=1,i=2,a=.1){if(i=i*2+1,a=Math.min(e/2,t/2,n/2,a),super(1,1,1,i,i,i),i===1)return;const r=this.toNonIndexed();this.index=null,this.attributes.position=r.attributes.position,this.attributes.normal=r.attributes.normal,this.attributes.uv=r.attributes.uv;const c=new z,o=new z,p=new z(e,t,n).divideScalar(2).subScalar(a),f=this.attributes.position.array,u=this.attributes.normal.array,l=this.attributes.uv.array,d=f.length/6,h=new z,A=.5/i;for(let b=0,m=0;b<f.length;b+=3,m+=2)switch(c.fromArray(f,b),o.copy(c),o.x-=Math.sign(o.x)*A,o.y-=Math.sign(o.y)*A,o.z-=Math.sign(o.z)*A,o.normalize(),f[b+0]=p.x*Math.sign(c.x)+o.x*a,f[b+1]=p.y*Math.sign(c.y)+o.y*a,f[b+2]=p.z*Math.sign(c.z)+o.z*a,u[b+0]=o.x,u[b+1]=o.y,u[b+2]=o.z,Math.floor(b/d)){case 0:h.set(1,0,0),l[m+0]=q(h,o,"z","y",a,n),l[m+1]=1-q(h,o,"y","z",a,t);break;case 1:h.set(-1,0,0),l[m+0]=1-q(h,o,"z","y",a,n),l[m+1]=1-q(h,o,"y","z",a,t);break;case 2:h.set(0,1,0),l[m+0]=1-q(h,o,"x","z",a,e),l[m+1]=q(h,o,"z","x",a,n);break;case 3:h.set(0,-1,0),l[m+0]=1-q(h,o,"x","z",a,e),l[m+1]=1-q(h,o,"z","x",a,n);break;case 4:h.set(0,0,1),l[m+0]=1-q(h,o,"x","y",a,e),l[m+1]=1-q(h,o,"y","x",a,t);break;case 5:h.set(0,0,-1),l[m+0]=q(h,o,"x","y",a,e),l[m+1]=1-q(h,o,"y","x",a,t);break}}}const Je=0,zn=1,En=2,ve=2,se=1.25,Ce=1,Kt=6*4+4+4,Qt=65535,Ln=Math.pow(2,-24),ie=Symbol("SKIP_GENERATION");function Un(s){return s.index?s.index.count:s.attributes.position.count}function bt(s){return Un(s)/3}function Fn(s,e=ArrayBuffer){return s>65535?new Uint32Array(new e(4*s)):new Uint16Array(new e(2*s))}function In(s,e){if(!s.index){const t=s.attributes.position.count,n=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Fn(t,n);s.setIndex(new xt(i,1));for(let a=0;a<t;a++)i[a]=a}}function Qe(s){const e=bt(s),t=s.drawRange,n=t.start/3,i=(t.start+t.count)/3,a=Math.max(0,n),r=Math.min(e,i)-a;return[{offset:Math.floor(a),count:Math.floor(r)}]}function tn(s){if(!s.groups||!s.groups.length)return Qe(s);const e=[],t=new Set,n=s.drawRange,i=n.start/3,a=(n.start+n.count)/3;for(const c of s.groups){const o=c.start/3,p=(c.start+c.count)/3;t.add(Math.max(i,o)),t.add(Math.min(a,p))}const r=Array.from(t.values()).sort((c,o)=>c-o);for(let c=0;c<r.length-1;c++){const o=r[c],p=r[c+1];e.push({offset:Math.floor(o),count:Math.floor(p-o)})}return e}function Rn(s){if(s.groups.length===0)return!1;const e=bt(s),t=tn(s).sort((a,r)=>a.offset-r.offset),n=t[t.length-1];n.count=Math.min(e-n.offset,n.count);let i=0;return t.forEach(({count:a})=>i+=a),e!==i}function F(s,e,t){return t.min.x=e[s],t.min.y=e[s+1],t.min.z=e[s+2],t.max.x=e[s+3],t.max.y=e[s+4],t.max.z=e[s+5],t}function Vn(s){s[0]=s[1]=s[2]=1/0,s[3]=s[4]=s[5]=-1/0}function ze(s){let e=-1,t=-1/0;for(let n=0;n<3;n++){const i=s[n+3]-s[n];i>t&&(t=i,e=n)}return e}function Ee(s,e){e.set(s)}function Le(s,e,t){let n,i;for(let a=0;a<3;a++){const r=a+3;n=s[a],i=e[a],t[a]=n<i?n:i,n=s[r],i=e[r],t[r]=n>i?n:i}}function Ft(s,e,t){for(let n=0;n<3;n++){const i=e[s+2*n],a=e[s+2*n+1],r=i-a,c=i+a;r<t[n]&&(t[n]=r),c>t[n+3]&&(t[n+3]=c)}}function Pt(s){const e=s[3]-s[0],t=s[4]-s[1],n=s[5]-s[2];return 2*(e*t+t*n+n*e)}function oe(s,e,t,n,i=null){let a=1/0,r=1/0,c=1/0,o=-1/0,p=-1/0,f=-1/0,u=1/0,l=1/0,d=1/0,h=-1/0,A=-1/0,b=-1/0;const m=i!==null;for(let x=e*6,y=(e+t)*6;x<y;x+=6){const w=s[x+0],g=s[x+1],T=w-g,S=w+g;T<a&&(a=T),S>o&&(o=S),m&&w<u&&(u=w),m&&w>h&&(h=w);const M=s[x+2],B=s[x+3],_=M-B,C=M+B;_<r&&(r=_),C>p&&(p=C),m&&M<l&&(l=M),m&&M>A&&(A=M);const P=s[x+4],v=s[x+5],E=P-v,L=P+v;E<c&&(c=E),L>f&&(f=L),m&&P<d&&(d=P),m&&P>b&&(b=P)}n[0]=a,n[1]=r,n[2]=c,n[3]=o,n[4]=p,n[5]=f,m&&(i[0]=u,i[1]=l,i[2]=d,i[3]=h,i[4]=A,i[5]=b)}function Dn(s,e,t,n){let i=1/0,a=1/0,r=1/0,c=-1/0,o=-1/0,p=-1/0;for(let f=e*6,u=(e+t)*6;f<u;f+=6){const l=s[f+0];l<i&&(i=l),l>c&&(c=l);const d=s[f+2];d<a&&(a=d),d>o&&(o=d);const h=s[f+4];h<r&&(r=h),h>p&&(p=h)}n[0]=i,n[1]=a,n[2]=r,n[3]=c,n[4]=o,n[5]=p}function kn(s,e){Vn(e);const t=s.attributes.position,n=s.index?s.index.array:null,i=bt(s),a=new Float32Array(i*6),r=t.normalized,c=t.array,o=t.offset||0;let p=3;t.isInterleavedBufferAttribute&&(p=t.data.stride);const f=["getX","getY","getZ"];for(let u=0;u<i;u++){const l=u*3,d=u*6;let h=l+0,A=l+1,b=l+2;n&&(h=n[h],A=n[A],b=n[b]),r||(h=h*p+o,A=A*p+o,b=b*p+o);for(let m=0;m<3;m++){let x,y,w;r?(x=t[f[m]](h),y=t[f[m]](A),w=t[f[m]](b)):(x=c[h+m],y=c[A+m],w=c[b+m]);let g=x;y<g&&(g=y),w<g&&(g=w);let T=x;y>T&&(T=y),w>T&&(T=w);const S=(T-g)/2,M=m*2;a[d+M+0]=g+S,a[d+M+1]=S+(Math.abs(g)+S)*Ln,g<e[m]&&(e[m]=g),T>e[m+3]&&(e[m+3]=T)}}return a}const O=32,Nn=(s,e)=>s.candidate-e.candidate,J=new Array(O).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),It=new Float32Array(6);function qn(s,e,t,n,i,a){let r=-1,c=0;if(a===Je)r=ze(e),r!==-1&&(c=(e[r]+e[r+3])/2);else if(a===zn)r=ze(s),r!==-1&&(c=Hn(t,n,i,r));else if(a===En){const o=Pt(s);let p=se*i;const f=n*6,u=(n+i)*6;for(let l=0;l<3;l++){const d=e[l],b=(e[l+3]-d)/O;if(i<O/4){const m=[...J];m.length=i;let x=0;for(let w=f;w<u;w+=6,x++){const g=m[x];g.candidate=t[w+2*l],g.count=0;const{bounds:T,leftCacheBounds:S,rightCacheBounds:M}=g;for(let B=0;B<3;B++)M[B]=1/0,M[B+3]=-1/0,S[B]=1/0,S[B+3]=-1/0,T[B]=1/0,T[B+3]=-1/0;Ft(w,t,T)}m.sort(Nn);let y=i;for(let w=0;w<y;w++){const g=m[w];for(;w+1<y&&m[w+1].candidate===g.candidate;)m.splice(w+1,1),y--}for(let w=f;w<u;w+=6){const g=t[w+2*l];for(let T=0;T<y;T++){const S=m[T];g>=S.candidate?Ft(w,t,S.rightCacheBounds):(Ft(w,t,S.leftCacheBounds),S.count++)}}for(let w=0;w<y;w++){const g=m[w],T=g.count,S=i-g.count,M=g.leftCacheBounds,B=g.rightCacheBounds;let _=0;T!==0&&(_=Pt(M)/o);let C=0;S!==0&&(C=Pt(B)/o);const P=Ce+se*(_*T+C*S);P<p&&(r=l,p=P,c=g.candidate)}}else{for(let y=0;y<O;y++){const w=J[y];w.count=0,w.candidate=d+b+y*b;const g=w.bounds;for(let T=0;T<3;T++)g[T]=1/0,g[T+3]=-1/0}for(let y=f;y<u;y+=6){let T=~~((t[y+2*l]-d)/b);T>=O&&(T=O-1);const S=J[T];S.count++,Ft(y,t,S.bounds)}const m=J[O-1];Ee(m.bounds,m.rightCacheBounds);for(let y=O-2;y>=0;y--){const w=J[y],g=J[y+1];Le(w.bounds,g.rightCacheBounds,w.rightCacheBounds)}let x=0;for(let y=0;y<O-1;y++){const w=J[y],g=w.count,T=w.bounds,M=J[y+1].rightCacheBounds;g!==0&&(x===0?Ee(T,It):Le(T,It,It)),x+=g;let B=0,_=0;x!==0&&(B=Pt(It)/o);const C=i-x;C!==0&&(_=Pt(M)/o);const P=Ce+se*(B*x+_*C);P<p&&(r=l,p=P,c=w.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:r,pos:c}}function Hn(s,e,t,n){let i=0;for(let a=e,r=e+t;a<r;a++)i+=s[a*6+n*2];return i/t}class Rt{constructor(){}}function Wn(s,e,t,n,i,a){let r=n,c=n+i-1;const o=a.pos,p=a.axis*2;for(;;){for(;r<=c&&t[r*6+p]<o;)r++;for(;r<=c&&t[c*6+p]>=o;)c--;if(r<c){for(let f=0;f<3;f++){let u=e[r*3+f];e[r*3+f]=e[c*3+f],e[c*3+f]=u}for(let f=0;f<6;f++){let u=t[r*6+f];t[r*6+f]=t[c*6+f],t[c*6+f]=u}r++,c--}else return r}}function $n(s,e,t,n,i,a){let r=n,c=n+i-1;const o=a.pos,p=a.axis*2;for(;;){for(;r<=c&&t[r*6+p]<o;)r++;for(;r<=c&&t[c*6+p]>=o;)c--;if(r<c){let f=s[r];s[r]=s[c],s[c]=f;for(let u=0;u<6;u++){let l=t[r*6+u];t[r*6+u]=t[c*6+u],t[c*6+u]=l}r++,c--}else return r}}function jn(s,e){const t=(s.index?s.index.count:s.attributes.position.count)/3,n=t>2**16,i=n?4:2,a=e?new SharedArrayBuffer(t*i):new ArrayBuffer(t*i),r=n?new Uint32Array(a):new Uint16Array(a);for(let c=0,o=r.length;c<o;c++)r[c]=c;return r}function Xn(s,e){const t=s.geometry,n=t.index?t.index.array:null,i=e.maxDepth,a=e.verbose,r=e.maxLeafTris,c=e.strategy,o=e.onProgress,p=bt(t),f=s._indirectBuffer;let u=!1;const l=new Float32Array(6),d=new Float32Array(6),h=kn(t,l),A=e.indirect?$n:Wn,b=[],m=e.indirect?Qe(t):tn(t);if(m.length===1){const w=m[0],g=new Rt;g.boundingData=l,Dn(h,w.offset,w.count,d),y(g,w.offset,w.count,d),b.push(g)}else for(let w of m){const g=new Rt;g.boundingData=new Float32Array(6),oe(h,w.offset,w.count,g.boundingData,d),y(g,w.offset,w.count,d),b.push(g)}return b;function x(w){o&&o(w/p)}function y(w,g,T,S=null,M=0){if(!u&&M>=i&&(u=!0,a&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),T<=r||M>=i)return x(g+T),w.offset=g,w.count=T,w;const B=qn(w.boundingData,S,h,g,T,c);if(B.axis===-1)return x(g+T),w.offset=g,w.count=T,w;const _=A(f,n,h,g,T,B);if(_===g||_===g+T)x(g+T),w.offset=g,w.count=T;else{w.splitAxis=B.axis;const C=new Rt,P=g,v=_-g;w.left=C,C.boundingData=new Float32Array(6),oe(h,P,v,C.boundingData,d),y(C,P,v,d,M+1);const E=new Rt,L=_,I=T-v;w.right=E,E.boundingData=new Float32Array(6),oe(h,L,I,E.boundingData,d),y(E,L,I,d,M+1)}return w}}function Yn(s,e){const t=s.geometry;e.indirect&&(s._indirectBuffer=jn(t,e.useSharedArrayBuffer),Rn(t)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),s._indirectBuffer||In(t,e);const n=Xn(s,e);let i,a,r;const c=[],o=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let u=0;u<n.length;u++){const l=n[u];let d=p(l);const h=new o(Kt*d);i=new Float32Array(h),a=new Uint32Array(h),r=new Uint16Array(h),f(0,l),c.push(h)}s._roots=c;return;function p(u){return u.count?1:1+p(u.left)+p(u.right)}function f(u,l){const d=u/4,h=u/2,A=!!l.count,b=l.boundingData;for(let m=0;m<6;m++)i[d+m]=b[m];if(A){const m=l.offset,x=l.count;return a[d+6]=m,r[h+14]=x,r[h+15]=Qt,u+Kt}else{const m=l.left,x=l.right,y=l.splitAxis;let w;if(w=f(u+Kt,m),w/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return a[d+6]=w/4,w=f(w,x),a[d+7]=y,w}}}class K{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let n=1/0,i=-1/0;for(let a=0,r=e.length;a<r;a++){const o=e[a][t];n=o<n?o:n,i=o>i?o:i}this.min=n,this.max=i}setFromPoints(e,t){let n=1/0,i=-1/0;for(let a=0,r=t.length;a<r;a++){const c=t[a],o=e.dot(c);n=o<n?o:n,i=o>i?o:i}this.min=n,this.max=i}isSeparated(e){return this.min>e.max||e.min>this.max}}K.prototype.setFromBox=function(){const s=new z;return function(t,n){const i=n.min,a=n.max;let r=1/0,c=-1/0;for(let o=0;o<=1;o++)for(let p=0;p<=1;p++)for(let f=0;f<=1;f++){s.x=i.x*o+a.x*(1-o),s.y=i.y*p+a.y*(1-p),s.z=i.z*f+a.z*(1-f);const u=t.dot(s);r=Math.min(u,r),c=Math.max(u,c)}this.min=r,this.max=c}}();const Zn=function(){const s=new z,e=new z,t=new z;return function(i,a,r){const c=i.start,o=s,p=a.start,f=e;t.subVectors(c,p),s.subVectors(i.end,i.start),e.subVectors(a.end,a.start);const u=t.dot(f),l=f.dot(o),d=f.dot(f),h=t.dot(o),b=o.dot(o)*d-l*l;let m,x;b!==0?m=(u*l-h*d)/b:m=0,x=(u+m*l)/d,r.x=m,r.y=x}}(),Be=function(){const s=new wt,e=new z,t=new z;return function(i,a,r,c){Zn(i,a,s);let o=s.x,p=s.y;if(o>=0&&o<=1&&p>=0&&p<=1){i.at(o,r),a.at(p,c);return}else if(o>=0&&o<=1){p<0?a.at(0,c):a.at(1,c),i.closestPointToPoint(c,!0,r);return}else if(p>=0&&p<=1){o<0?i.at(0,r):i.at(1,r),a.closestPointToPoint(r,!0,c);return}else{let f;o<0?f=i.start:f=i.end;let u;p<0?u=a.start:u=a.end;const l=e,d=t;if(i.closestPointToPoint(u,!0,e),a.closestPointToPoint(f,!0,t),l.distanceToSquared(u)<=d.distanceToSquared(f)){r.copy(l),c.copy(u);return}else{r.copy(f),c.copy(d);return}}}}(),Gn=function(){const s=new z,e=new z,t=new Oe,n=new Z;return function(a,r){const{radius:c,center:o}=a,{a:p,b:f,c:u}=r;if(n.start=p,n.end=f,n.closestPointToPoint(o,!0,s).distanceTo(o)<=c||(n.start=p,n.end=u,n.closestPointToPoint(o,!0,s).distanceTo(o)<=c)||(n.start=f,n.end=u,n.closestPointToPoint(o,!0,s).distanceTo(o)<=c))return!0;const A=r.getPlane(t);if(Math.abs(A.distanceToPoint(o))<=c){const m=A.projectPoint(o,e);if(r.containsPoint(m))return!0}return!1}}(),On=1e-15;function re(s){return Math.abs(s)<On}class Y extends Et{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new z),this.satBounds=new Array(4).fill().map(()=>new K),this.points=[this.a,this.b,this.c],this.sphere=new rn,this.plane=new Oe,this.needsUpdate=!0}intersectsSphere(e){return Gn(e,this)}update(){const e=this.a,t=this.b,n=this.c,i=this.points,a=this.satAxes,r=this.satBounds,c=a[0],o=r[0];this.getNormal(c),o.setFromPoints(c,i);const p=a[1],f=r[1];p.subVectors(e,t),f.setFromPoints(p,i);const u=a[2],l=r[2];u.subVectors(t,n),l.setFromPoints(u,i);const d=a[3],h=r[3];d.subVectors(n,e),h.setFromPoints(d,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,e),this.needsUpdate=!1}}Y.prototype.closestPointToSegment=function(){const s=new z,e=new z,t=new Z;return function(i,a=null,r=null){const{start:c,end:o}=i,p=this.points;let f,u=1/0;for(let l=0;l<3;l++){const d=(l+1)%3;t.start.copy(p[l]),t.end.copy(p[d]),Be(t,i,s,e),f=s.distanceToSquared(e),f<u&&(u=f,a&&a.copy(s),r&&r.copy(e))}return this.closestPointToPoint(c,s),f=c.distanceToSquared(s),f<u&&(u=f,a&&a.copy(s),r&&r.copy(c)),this.closestPointToPoint(o,s),f=o.distanceToSquared(s),f<u&&(u=f,a&&a.copy(s),r&&r.copy(o)),Math.sqrt(u)}}();Y.prototype.intersectsTriangle=function(){const s=new Y,e=new Array(3),t=new Array(3),n=new K,i=new K,a=new z,r=new z,c=new z,o=new z,p=new z,f=new Z,u=new Z,l=new Z,d=new z;function h(A,b,m){const x=A.points;let y=0,w=-1;for(let g=0;g<3;g++){const{start:T,end:S}=f;T.copy(x[g]),S.copy(x[(g+1)%3]),f.delta(r);const M=re(b.distanceToPoint(T));if(re(b.normal.dot(r))&&M){m.copy(f),y=2;break}const B=b.intersectLine(f,d);if(!B&&M&&d.copy(T),(B||M)&&!re(d.distanceTo(S))){if(y<=1)(y===1?m.start:m.end).copy(d),M&&(w=y);else if(y>=2){(w===1?m.start:m.end).copy(d),y=2;break}if(y++,y===2&&w===-1)break}}return y}return function(b,m=null,x=!1){this.needsUpdate&&this.update(),b.isExtendedTriangle?b.needsUpdate&&b.update():(s.copy(b),s.update(),b=s);const y=this.plane,w=b.plane;if(Math.abs(y.normal.dot(w.normal))>1-1e-10){const g=this.satBounds,T=this.satAxes;t[0]=b.a,t[1]=b.b,t[2]=b.c;for(let B=0;B<4;B++){const _=g[B],C=T[B];if(n.setFromPoints(C,t),_.isSeparated(n))return!1}const S=b.satBounds,M=b.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let B=0;B<4;B++){const _=S[B],C=M[B];if(n.setFromPoints(C,e),_.isSeparated(n))return!1}for(let B=0;B<4;B++){const _=T[B];for(let C=0;C<4;C++){const P=M[C];if(a.crossVectors(_,P),n.setFromPoints(a,e),i.setFromPoints(a,t),n.isSeparated(i))return!1}}return m&&(x||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),m.start.set(0,0,0),m.end.set(0,0,0)),!0}else{const g=h(this,w,u);if(g===1&&b.containsPoint(u.end))return m&&(m.start.copy(u.end),m.end.copy(u.end)),!0;if(g!==2)return!1;const T=h(b,y,l);if(T===1&&this.containsPoint(l.end))return m&&(m.start.copy(l.end),m.end.copy(l.end)),!0;if(T!==2)return!1;if(u.delta(c),l.delta(o),c.dot(o)<0){let v=l.start;l.start=l.end,l.end=v}const S=u.start.dot(c),M=u.end.dot(c),B=l.start.dot(c),_=l.end.dot(c),C=M<B,P=S<_;return S!==_&&B!==M&&C===P?!1:(m&&(p.subVectors(u.start,l.start),p.dot(c)>0?m.start.copy(u.start):m.start.copy(l.start),p.subVectors(u.end,l.end),p.dot(c)<0?m.end.copy(u.end):m.end.copy(l.end)),!0)}}}();Y.prototype.distanceToPoint=function(){const s=new z;return function(t){return this.closestPointToPoint(t,s),t.distanceTo(s)}}();Y.prototype.distanceToTriangle=function(){const s=new z,e=new z,t=["a","b","c"],n=new Z,i=new Z;return function(r,c=null,o=null){const p=c||o?n:null;if(this.intersectsTriangle(r,p))return(c||o)&&(c&&p.getCenter(c),o&&p.getCenter(o)),0;let f=1/0;for(let u=0;u<3;u++){let l;const d=t[u],h=r[d];this.closestPointToPoint(h,s),l=h.distanceToSquared(s),l<f&&(f=l,c&&c.copy(s),o&&o.copy(h));const A=this[d];r.closestPointToPoint(A,s),l=A.distanceToSquared(s),l<f&&(f=l,c&&c.copy(A),o&&o.copy(s))}for(let u=0;u<3;u++){const l=t[u],d=t[(u+1)%3];n.set(this[l],this[d]);for(let h=0;h<3;h++){const A=t[h],b=t[(h+1)%3];i.set(r[A],r[b]),Be(n,i,s,e);const m=s.distanceToSquared(e);m<f&&(f=m,c&&c.copy(s),o&&o.copy(e))}}return Math.sqrt(f)}}();class V{constructor(e,t,n){this.isOrientedBox=!0,this.min=new z,this.max=new z,this.matrix=new G,this.invMatrix=new G,this.points=new Array(8).fill().map(()=>new z),this.satAxes=new Array(3).fill().map(()=>new z),this.satBounds=new Array(3).fill().map(()=>new K),this.alignedSatBounds=new Array(3).fill().map(()=>new K),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),n&&this.matrix.copy(n)}set(e,t,n){this.min.copy(e),this.max.copy(t),this.matrix.copy(n),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}V.prototype.update=function(){return function(){const e=this.matrix,t=this.min,n=this.max,i=this.points;for(let p=0;p<=1;p++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){const l=1*p|2*f|4*u,d=i[l];d.x=p?n.x:t.x,d.y=f?n.y:t.y,d.z=u?n.z:t.z,d.applyMatrix4(e)}const a=this.satBounds,r=this.satAxes,c=i[0];for(let p=0;p<3;p++){const f=r[p],u=a[p],l=1<<p,d=i[l];f.subVectors(c,d),u.setFromPoints(f,i)}const o=this.alignedSatBounds;o[0].setFromPointsField(i,"x"),o[1].setFromPointsField(i,"y"),o[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();V.prototype.intersectsBox=function(){const s=new K;return function(t){this.needsUpdate&&this.update();const n=t.min,i=t.max,a=this.satBounds,r=this.satAxes,c=this.alignedSatBounds;if(s.min=n.x,s.max=i.x,c[0].isSeparated(s)||(s.min=n.y,s.max=i.y,c[1].isSeparated(s))||(s.min=n.z,s.max=i.z,c[2].isSeparated(s)))return!1;for(let o=0;o<3;o++){const p=r[o],f=a[o];if(s.setFromBox(p,t),f.isSeparated(s))return!1}return!0}}();V.prototype.intersectsTriangle=function(){const s=new Y,e=new Array(3),t=new K,n=new K,i=new z;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(s.copy(r),s.update(),r=s);const c=this.satBounds,o=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let l=0;l<3;l++){const d=c[l],h=o[l];if(t.setFromPoints(h,e),d.isSeparated(t))return!1}const p=r.satBounds,f=r.satAxes,u=this.points;for(let l=0;l<3;l++){const d=p[l],h=f[l];if(t.setFromPoints(h,u),d.isSeparated(t))return!1}for(let l=0;l<3;l++){const d=o[l];for(let h=0;h<4;h++){const A=f[h];if(i.crossVectors(d,A),t.setFromPoints(i,e),n.setFromPoints(i,u),t.isSeparated(n))return!1}}return!0}}();V.prototype.closestPointToPoint=function(){return function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();V.prototype.distanceToPoint=function(){const s=new z;return function(t){return this.closestPointToPoint(t,s),t.distanceTo(s)}}();V.prototype.distanceToBox=function(){const s=["x","y","z"],e=new Array(12).fill().map(()=>new Z),t=new Array(12).fill().map(()=>new Z),n=new z,i=new z;return function(r,c=0,o=null,p=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(o||p)&&(r.getCenter(i),this.closestPointToPoint(i,n),r.closestPointToPoint(n,i),o&&o.copy(n),p&&p.copy(i)),0;const f=c*c,u=r.min,l=r.max,d=this.points;let h=1/0;for(let b=0;b<8;b++){const m=d[b];i.copy(m).clamp(u,l);const x=m.distanceToSquared(i);if(x<h&&(h=x,o&&o.copy(m),p&&p.copy(i),x<f))return Math.sqrt(x)}let A=0;for(let b=0;b<3;b++)for(let m=0;m<=1;m++)for(let x=0;x<=1;x++){const y=(b+1)%3,w=(b+2)%3,g=m<<y|x<<w,T=1<<b|m<<y|x<<w,S=d[g],M=d[T];e[A].set(S,M);const _=s[b],C=s[y],P=s[w],v=t[A],E=v.start,L=v.end;E[_]=u[_],E[C]=m?u[C]:l[C],E[P]=x?u[P]:l[C],L[_]=l[_],L[C]=m?u[C]:l[C],L[P]=x?u[P]:l[C],A++}for(let b=0;b<=1;b++)for(let m=0;m<=1;m++)for(let x=0;x<=1;x++){i.x=b?l.x:u.x,i.y=m?l.y:u.y,i.z=x?l.z:u.z,this.closestPointToPoint(i,n);const y=i.distanceToSquared(n);if(y<h&&(h=y,o&&o.copy(n),p&&p.copy(i),y<f))return Math.sqrt(y)}for(let b=0;b<12;b++){const m=e[b];for(let x=0;x<12;x++){const y=t[x];Be(m,y,n,i);const w=n.distanceToSquared(i);if(w<h&&(h=w,o&&o.copy(n),p&&p.copy(i),w<f))return Math.sqrt(w)}}return Math.sqrt(h)}}();class Pe{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}class Kn extends Pe{constructor(){super(()=>new Y)}}const H=new Kn;function D(s,e){return e[s+15]===65535}function k(s,e){return e[s+6]}function W(s,e){return e[s+14]}function $(s){return s+8}function j(s,e){return e[s+6]}function en(s,e){return e[s+7]}class Jn{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const e=[];let t=null;this.setBuffer=n=>{t&&e.push(t),t=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,e.length!==0&&this.setBuffer(e.pop())}}}const U=new Jn;let tt,yt;const rt=[],Vt=new Pe(()=>new N);function Qn(s,e,t,n,i,a){tt=Vt.getPrimitive(),yt=Vt.getPrimitive(),rt.push(tt,yt),U.setBuffer(s._roots[e]);const r=me(0,s.geometry,t,n,i,a);U.clearBuffer(),Vt.releasePrimitive(tt),Vt.releasePrimitive(yt),rt.pop(),rt.pop();const c=rt.length;return c>0&&(yt=rt[c-1],tt=rt[c-2]),r}function me(s,e,t,n,i=null,a=0,r=0){const{float32Array:c,uint16Array:o,uint32Array:p}=U;let f=s*2;if(D(f,o)){const l=k(s,p),d=W(f,o);return F(s,c,tt),n(l,d,!1,r,a+s,tt)}else{let _=function(P){const{uint16Array:v,uint32Array:E}=U;let L=P*2;for(;!D(L,v);)P=$(P),L=P*2;return k(P,E)},C=function(P){const{uint16Array:v,uint32Array:E}=U;let L=P*2;for(;!D(L,v);)P=j(P,E),L=P*2;return k(P,E)+W(L,v)};const l=$(s),d=j(s,p);let h=l,A=d,b,m,x,y;if(i&&(x=tt,y=yt,F(h,c,x),F(A,c,y),b=i(x),m=i(y),m<b)){h=d,A=l;const P=b;b=m,m=P,x=y}x||(x=tt,F(h,c,x));const w=D(h*2,o),g=t(x,w,b,r+1,a+h);let T;if(g===ve){const P=_(h),E=C(h)-P;T=n(P,E,!0,r+1,a+h,x)}else T=g&&me(h,e,t,n,i,a,r+1);if(T)return!0;y=yt,F(A,c,y);const S=D(A*2,o),M=t(y,S,m,r+1,a+A);let B;if(M===ve){const P=_(A),E=C(A)-P;B=n(P,E,!0,r+1,a+A,y)}else B=M&&me(A,e,t,n,i,a,r+1);return!!B}}const Mt=new z,ce=new z;function ts(s,e,t={},n=0,i=1/0){const a=n*n,r=i*i;let c=1/0,o=null;if(s.shapecast({boundsTraverseOrder:f=>(Mt.copy(e).clamp(f.min,f.max),Mt.distanceToSquared(e)),intersectsBounds:(f,u,l)=>l<c&&l<r,intersectsTriangle:(f,u)=>{f.closestPointToPoint(e,Mt);const l=e.distanceToSquared(Mt);return l<c&&(ce.copy(Mt),c=l,o=u),l<a}}),c===1/0)return null;const p=Math.sqrt(c);return t.point?t.point.copy(ce):t.point=ce.clone(),t.distance=p,t.faceIndex=o,t}const ct=new z,at=new z,lt=new z,Dt=new wt,kt=new wt,Nt=new wt,Ue=new z,Fe=new z,Ie=new z,qt=new z;function es(s,e,t,n,i,a){let r;return a===cn?r=s.intersectTriangle(n,t,e,!0,i):r=s.intersectTriangle(e,t,n,a!==an,i),r===null?null:{distance:s.origin.distanceTo(i),point:i.clone()}}function ns(s,e,t,n,i,a,r,c,o){ct.fromBufferAttribute(e,a),at.fromBufferAttribute(e,r),lt.fromBufferAttribute(e,c);const p=es(s,ct,at,lt,qt,o);if(p){n&&(Dt.fromBufferAttribute(n,a),kt.fromBufferAttribute(n,r),Nt.fromBufferAttribute(n,c),p.uv=Et.getInterpolation(qt,ct,at,lt,Dt,kt,Nt,new wt)),i&&(Dt.fromBufferAttribute(i,a),kt.fromBufferAttribute(i,r),Nt.fromBufferAttribute(i,c),p.uv1=Et.getInterpolation(qt,ct,at,lt,Dt,kt,Nt,new wt)),t&&(Ue.fromBufferAttribute(t,a),Fe.fromBufferAttribute(t,r),Ie.fromBufferAttribute(t,c),p.normal=Et.getInterpolation(qt,ct,at,lt,Ue,Fe,Ie,new z),p.normal.dot(s.direction)>0&&p.normal.multiplyScalar(-1));const f={a,b:r,c,normal:new z,materialIndex:0};Et.getNormal(ct,at,lt,f.normal),p.face=f,p.faceIndex=a}return p}function te(s,e,t,n,i){const a=n*3;let r=a+0,c=a+1,o=a+2;const p=s.index;s.index&&(r=p.getX(r),c=p.getX(c),o=p.getX(o));const{position:f,normal:u,uv:l,uv1:d}=s.attributes,h=ns(t,f,u,l,d,r,c,o,e);return h?(h.faceIndex=n,i&&i.push(h),h):null}function R(s,e,t,n){const i=s.a,a=s.b,r=s.c;let c=e,o=e+1,p=e+2;t&&(c=t.getX(c),o=t.getX(o),p=t.getX(p)),i.x=n.getX(c),i.y=n.getY(c),i.z=n.getZ(c),a.x=n.getX(o),a.y=n.getY(o),a.z=n.getZ(o),r.x=n.getX(p),r.y=n.getY(p),r.z=n.getZ(p)}function ss(s,e,t,n,i,a){const{geometry:r,_indirectBuffer:c}=s;for(let o=n,p=n+i;o<p;o++)te(r,e,t,o,a)}function is(s,e,t,n,i){const{geometry:a,_indirectBuffer:r}=s;let c=1/0,o=null;for(let p=n,f=n+i;p<f;p++){let u;u=te(a,e,t,p),u&&u.distance<c&&(o=u,c=u.distance)}return o}function os(s,e,t,n,i,a,r){const{geometry:c}=t,{index:o}=c,p=c.attributes.position;for(let f=s,u=e+s;f<u;f++){let l;if(l=f,R(r,l*3,o,p),r.needsUpdate=!0,n(r,l,i,a))return!0}return!1}function rs(s,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=s.geometry,n=t.index?t.index.array:null,i=t.attributes.position;let a,r,c,o,p=0;const f=s._roots;for(let l=0,d=f.length;l<d;l++)a=f[l],r=new Uint32Array(a),c=new Uint16Array(a),o=new Float32Array(a),u(0,p),p+=a.byteLength;function u(l,d,h=!1){const A=l*2;if(c[A+15]===Qt){const m=r[l+6],x=c[A+14];let y=1/0,w=1/0,g=1/0,T=-1/0,S=-1/0,M=-1/0;for(let B=3*m,_=3*(m+x);B<_;B++){let C=n[B];const P=i.getX(C),v=i.getY(C),E=i.getZ(C);P<y&&(y=P),P>T&&(T=P),v<w&&(w=v),v>S&&(S=v),E<g&&(g=E),E>M&&(M=E)}return o[l+0]!==y||o[l+1]!==w||o[l+2]!==g||o[l+3]!==T||o[l+4]!==S||o[l+5]!==M?(o[l+0]=y,o[l+1]=w,o[l+2]=g,o[l+3]=T,o[l+4]=S,o[l+5]=M,!0):!1}else{const m=l+8,x=r[l+6],y=m+d,w=x+d;let g=h,T=!1,S=!1;e?g||(T=e.has(y),S=e.has(w),g=!T&&!S):(T=!0,S=!0);const M=g||T,B=g||S;let _=!1;M&&(_=u(m,d,g));let C=!1;B&&(C=u(x,d,g));const P=_||C;if(P)for(let v=0;v<3;v++){const E=m+v,L=x+v,I=o[E],gt=o[E+3],At=o[L],Tt=o[L+3];o[l+v]=I<At?I:At,o[l+v+3]=gt>Tt?gt:Tt}return P}}}const Re=new N;function et(s,e,t,n){return F(s,e,Re),t.intersectBox(Re,n)}function cs(s,e,t,n,i,a){const{geometry:r,_indirectBuffer:c}=s;for(let o=n,p=n+i;o<p;o++){let f=c?c[o]:o;te(r,e,t,f,a)}}function as(s,e,t,n,i){const{geometry:a,_indirectBuffer:r}=s;let c=1/0,o=null;for(let p=n,f=n+i;p<f;p++){let u;u=te(a,e,t,r?r[p]:p),u&&u.distance<c&&(o=u,c=u.distance)}return o}function ls(s,e,t,n,i,a,r){const{geometry:c}=t,{index:o}=c,p=c.attributes.position;for(let f=s,u=e+s;f<u;f++){let l;if(l=t.resolveTriangleIndex(f),R(r,l*3,o,p),r.needsUpdate=!0,n(r,l,i,a))return!0}return!1}const Ve=new z;function fs(s,e,t,n,i){U.setBuffer(s._roots[e]),ye(0,s,t,n,i),U.clearBuffer()}function ye(s,e,t,n,i){const{float32Array:a,uint16Array:r,uint32Array:c}=U,o=s*2;if(D(o,r)){const f=k(s,c),u=W(o,r);ss(e,t,n,f,u,i)}else{const f=$(s);et(f,a,n,Ve)&&ye(f,e,t,n,i);const u=j(s,c);et(u,a,n,Ve)&&ye(u,e,t,n,i)}}const De=new z,us=["x","y","z"];function ps(s,e,t,n){U.setBuffer(s._roots[e]);const i=xe(0,s,t,n);return U.clearBuffer(),i}function xe(s,e,t,n){const{float32Array:i,uint16Array:a,uint32Array:r}=U;let c=s*2;if(D(c,a)){const p=k(s,r),f=W(c,a);return is(e,t,n,p,f)}else{const p=en(s,r),f=us[p],l=n.direction[f]>=0;let d,h;l?(d=$(s),h=j(s,r)):(d=j(s,r),h=$(s));const b=et(d,i,n,De)?xe(d,e,t,n):null;if(b){const y=b.point[f];if(l?y<=i[h+p]:y>=i[h+p+3])return b}const x=et(h,i,n,De)?xe(h,e,t,n):null;return b&&x?b.distance<=x.distance?b:x:b||x||null}}const Ht=new N,ft=new Y,ut=new Y,St=new G,ke=new V,Wt=new V;function ds(s,e,t,n){U.setBuffer(s._roots[e]);const i=we(0,s,t,n);return U.clearBuffer(),i}function we(s,e,t,n,i=null){const{float32Array:a,uint16Array:r,uint32Array:c}=U;let o=s*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),ke.set(t.boundingBox.min,t.boundingBox.max,n),i=ke),D(o,r)){const f=e.geometry,u=f.index,l=f.attributes.position,d=t.index,h=t.attributes.position,A=k(s,c),b=W(o,r);if(St.copy(n).invert(),t.boundsTree)return F(s,a,Wt),Wt.matrix.copy(St),Wt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>Wt.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(n),x.b.applyMatrix4(n),x.c.applyMatrix4(n),x.needsUpdate=!0;for(let y=A*3,w=(b+A)*3;y<w;y+=3)if(R(ut,y,u,l),ut.needsUpdate=!0,x.intersectsTriangle(ut))return!0;return!1}});for(let m=A*3,x=(b+A)*3;m<x;m+=3){R(ft,m,u,l),ft.a.applyMatrix4(St),ft.b.applyMatrix4(St),ft.c.applyMatrix4(St),ft.needsUpdate=!0;for(let y=0,w=d.count;y<w;y+=3)if(R(ut,y,d,h),ut.needsUpdate=!0,ft.intersectsTriangle(ut))return!0}}else{const f=s+8,u=c[s+6];return F(f,a,Ht),!!(i.intersectsBox(Ht)&&we(f,e,t,n,i)||(F(u,a,Ht),i.intersectsBox(Ht)&&we(u,e,t,n,i)))}}const $t=new G,ae=new V,_t=new V,hs=new z,ms=new z,ys=new z,xs=new z;function ws(s,e,t,n={},i={},a=0,r=1/0){e.boundingBox||e.computeBoundingBox(),ae.set(e.boundingBox.min,e.boundingBox.max,t),ae.needsUpdate=!0;const c=s.geometry,o=c.attributes.position,p=c.index,f=e.attributes.position,u=e.index,l=H.getPrimitive(),d=H.getPrimitive();let h=hs,A=ms,b=null,m=null;i&&(b=ys,m=xs);let x=1/0,y=null,w=null;return $t.copy(t).invert(),_t.matrix.copy($t),s.shapecast({boundsTraverseOrder:g=>ae.distanceToBox(g),intersectsBounds:(g,T,S)=>S<x&&S<r?(T&&(_t.min.copy(g.min),_t.max.copy(g.max),_t.needsUpdate=!0),!0):!1,intersectsRange:(g,T)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:M=>_t.distanceToBox(M),intersectsBounds:(M,B,_)=>_<x&&_<r,intersectsRange:(M,B)=>{for(let _=M,C=M+B;_<C;_++){R(d,3*_,u,f),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let P=g,v=g+T;P<v;P++){R(l,3*P,p,o),l.needsUpdate=!0;const E=l.distanceToTriangle(d,h,b);if(E<x&&(A.copy(h),m&&m.copy(b),x=E,y=P,w=_),E<a)return!0}}}});{const S=bt(e);for(let M=0,B=S;M<B;M++){R(d,3*M,u,f),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let _=g,C=g+T;_<C;_++){R(l,3*_,p,o),l.needsUpdate=!0;const P=l.distanceToTriangle(d,h,b);if(P<x&&(A.copy(h),m&&m.copy(b),x=P,y=_,w=M),P<a)return!0}}}}}),H.releasePrimitive(l),H.releasePrimitive(d),x===1/0?null:(n.point?n.point.copy(A):n.point=A.clone(),n.distance=x,n.faceIndex=y,i&&(i.point?i.point.copy(m):i.point=m.clone(),i.point.applyMatrix4($t),A.applyMatrix4($t),i.distance=A.sub(i.point).length(),i.faceIndex=w),n)}function bs(s,e=null){e&&Array.isArray(e)&&(e=new Set(e));const t=s.geometry,n=t.index?t.index.array:null,i=t.attributes.position;let a,r,c,o,p=0;const f=s._roots;for(let l=0,d=f.length;l<d;l++)a=f[l],r=new Uint32Array(a),c=new Uint16Array(a),o=new Float32Array(a),u(0,p),p+=a.byteLength;function u(l,d,h=!1){const A=l*2;if(c[A+15]===Qt){const m=r[l+6],x=c[A+14];let y=1/0,w=1/0,g=1/0,T=-1/0,S=-1/0,M=-1/0;for(let B=m,_=m+x;B<_;B++){const C=3*s.resolveTriangleIndex(B);for(let P=0;P<3;P++){let v=C+P;v=n?n[v]:v;const E=i.getX(v),L=i.getY(v),I=i.getZ(v);E<y&&(y=E),E>T&&(T=E),L<w&&(w=L),L>S&&(S=L),I<g&&(g=I),I>M&&(M=I)}}return o[l+0]!==y||o[l+1]!==w||o[l+2]!==g||o[l+3]!==T||o[l+4]!==S||o[l+5]!==M?(o[l+0]=y,o[l+1]=w,o[l+2]=g,o[l+3]=T,o[l+4]=S,o[l+5]=M,!0):!1}else{const m=l+8,x=r[l+6],y=m+d,w=x+d;let g=h,T=!1,S=!1;e?g||(T=e.has(y),S=e.has(w),g=!T&&!S):(T=!0,S=!0);const M=g||T,B=g||S;let _=!1;M&&(_=u(m,d,g));let C=!1;B&&(C=u(x,d,g));const P=_||C;if(P)for(let v=0;v<3;v++){const E=m+v,L=x+v,I=o[E],gt=o[E+3],At=o[L],Tt=o[L+3];o[l+v]=I<At?I:At,o[l+v+3]=gt>Tt?gt:Tt}return P}}}const Ne=new z;function gs(s,e,t,n,i){U.setBuffer(s._roots[e]),be(0,s,t,n,i),U.clearBuffer()}function be(s,e,t,n,i){const{float32Array:a,uint16Array:r,uint32Array:c}=U,o=s*2;if(D(o,r)){const f=k(s,c),u=W(o,r);cs(e,t,n,f,u,i)}else{const f=$(s);et(f,a,n,Ne)&&be(f,e,t,n,i);const u=j(s,c);et(u,a,n,Ne)&&be(u,e,t,n,i)}}const qe=new z,As=["x","y","z"];function Ts(s,e,t,n){U.setBuffer(s._roots[e]);const i=ge(0,s,t,n);return U.clearBuffer(),i}function ge(s,e,t,n){const{float32Array:i,uint16Array:a,uint32Array:r}=U;let c=s*2;if(D(c,a)){const p=k(s,r),f=W(c,a);return as(e,t,n,p,f)}else{const p=en(s,r),f=As[p],l=n.direction[f]>=0;let d,h;l?(d=$(s),h=j(s,r)):(d=j(s,r),h=$(s));const b=et(d,i,n,qe)?ge(d,e,t,n):null;if(b){const y=b.point[f];if(l?y<=i[h+p]:y>=i[h+p+3])return b}const x=et(h,i,n,qe)?ge(h,e,t,n):null;return b&&x?b.distance<=x.distance?b:x:b||x||null}}const jt=new N,pt=new Y,dt=new Y,vt=new G,He=new V,Xt=new V;function Bs(s,e,t,n){U.setBuffer(s._roots[e]);const i=Ae(0,s,t,n);return U.clearBuffer(),i}function Ae(s,e,t,n,i=null){const{float32Array:a,uint16Array:r,uint32Array:c}=U;let o=s*2;if(i===null&&(t.boundingBox||t.computeBoundingBox(),He.set(t.boundingBox.min,t.boundingBox.max,n),i=He),D(o,r)){const f=e.geometry,u=f.index,l=f.attributes.position,d=t.index,h=t.attributes.position,A=k(s,c),b=W(o,r);if(vt.copy(n).invert(),t.boundsTree)return F(s,a,Xt),Xt.matrix.copy(vt),Xt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>Xt.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(n),x.b.applyMatrix4(n),x.c.applyMatrix4(n),x.needsUpdate=!0;for(let y=A,w=b+A;y<w;y++)if(R(dt,3*e.resolveTriangleIndex(y),u,l),dt.needsUpdate=!0,x.intersectsTriangle(dt))return!0;return!1}});for(let m=A,x=b+A;m<x;m++){const y=e.resolveTriangleIndex(m);R(pt,3*y,u,l),pt.a.applyMatrix4(vt),pt.b.applyMatrix4(vt),pt.c.applyMatrix4(vt),pt.needsUpdate=!0;for(let w=0,g=d.count;w<g;w+=3)if(R(dt,w,d,h),dt.needsUpdate=!0,pt.intersectsTriangle(dt))return!0}}else{const f=s+8,u=c[s+6];return F(f,a,jt),!!(i.intersectsBox(jt)&&Ae(f,e,t,n,i)||(F(u,a,jt),i.intersectsBox(jt)&&Ae(u,e,t,n,i)))}}const Yt=new G,le=new V,Ct=new V,Ps=new z,Ms=new z,Ss=new z,_s=new z;function vs(s,e,t,n={},i={},a=0,r=1/0){e.boundingBox||e.computeBoundingBox(),le.set(e.boundingBox.min,e.boundingBox.max,t),le.needsUpdate=!0;const c=s.geometry,o=c.attributes.position,p=c.index,f=e.attributes.position,u=e.index,l=H.getPrimitive(),d=H.getPrimitive();let h=Ps,A=Ms,b=null,m=null;i&&(b=Ss,m=_s);let x=1/0,y=null,w=null;return Yt.copy(t).invert(),Ct.matrix.copy(Yt),s.shapecast({boundsTraverseOrder:g=>le.distanceToBox(g),intersectsBounds:(g,T,S)=>S<x&&S<r?(T&&(Ct.min.copy(g.min),Ct.max.copy(g.max),Ct.needsUpdate=!0),!0):!1,intersectsRange:(g,T)=>{if(e.boundsTree){const S=e.boundsTree;return S.shapecast({boundsTraverseOrder:M=>Ct.distanceToBox(M),intersectsBounds:(M,B,_)=>_<x&&_<r,intersectsRange:(M,B)=>{for(let _=M,C=M+B;_<C;_++){const P=S.resolveTriangleIndex(_);R(d,3*P,u,f),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let v=g,E=g+T;v<E;v++){const L=s.resolveTriangleIndex(v);R(l,3*L,p,o),l.needsUpdate=!0;const I=l.distanceToTriangle(d,h,b);if(I<x&&(A.copy(h),m&&m.copy(b),x=I,y=v,w=_),I<a)return!0}}}})}else{const S=bt(e);for(let M=0,B=S;M<B;M++){R(d,3*M,u,f),d.a.applyMatrix4(t),d.b.applyMatrix4(t),d.c.applyMatrix4(t),d.needsUpdate=!0;for(let _=g,C=g+T;_<C;_++){const P=s.resolveTriangleIndex(_);R(l,3*P,p,o),l.needsUpdate=!0;const v=l.distanceToTriangle(d,h,b);if(v<x&&(A.copy(h),m&&m.copy(b),x=v,y=_,w=M),v<a)return!0}}}}}),H.releasePrimitive(l),H.releasePrimitive(d),x===1/0?null:(n.point?n.point.copy(A):n.point=A.clone(),n.distance=x,n.faceIndex=y,i&&(i.point?i.point.copy(m):i.point=m.clone(),i.point.applyMatrix4(Yt),A.applyMatrix4(Yt),i.distance=A.sub(i.point).length(),i.faceIndex=w),n)}function Cs(){return typeof SharedArrayBuffer<"u"}const Ut=new U.constructor,Jt=new U.constructor,Q=new Pe(()=>new N),ht=new N,mt=new N,fe=new N,ue=new N;let pe=!1;function zs(s,e,t,n){if(pe)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");pe=!0;const i=s._roots,a=e._roots;let r,c=0,o=0;const p=new G().copy(t).invert();for(let f=0,u=i.length;f<u;f++){Ut.setBuffer(i[f]),o=0;const l=Q.getPrimitive();F(0,Ut.float32Array,l),l.applyMatrix4(p);for(let d=0,h=a.length;d<h&&(Jt.setBuffer(a[f]),r=X(0,0,t,p,n,c,o,0,0,l),Jt.clearBuffer(),o+=a[d].length,!r);d++);if(Q.releasePrimitive(l),Ut.clearBuffer(),c+=i[f].length,r)break}return pe=!1,r}function X(s,e,t,n,i,a=0,r=0,c=0,o=0,p=null,f=!1){let u,l;f?(u=Jt,l=Ut):(u=Ut,l=Jt);const d=u.float32Array,h=u.uint32Array,A=u.uint16Array,b=l.float32Array,m=l.uint32Array,x=l.uint16Array,y=s*2,w=e*2,g=D(y,A),T=D(w,x);let S=!1;if(T&&g)f?S=i(k(e,m),W(e*2,x),k(s,h),W(s*2,A),o,r+e,c,a+s):S=i(k(s,h),W(s*2,A),k(e,m),W(e*2,x),c,a+s,o,r+e);else if(T){const M=Q.getPrimitive();F(e,b,M),M.applyMatrix4(t);const B=$(s),_=j(s,h);F(B,d,ht),F(_,d,mt);const C=M.intersectsBox(ht),P=M.intersectsBox(mt);S=C&&X(e,B,n,t,i,r,a,o,c+1,M,!f)||P&&X(e,_,n,t,i,r,a,o,c+1,M,!f),Q.releasePrimitive(M)}else{const M=$(e),B=j(e,m);F(M,b,fe),F(B,b,ue);const _=p.intersectsBox(fe),C=p.intersectsBox(ue);if(_&&C)S=X(s,M,t,n,i,a,r,c,o+1,p,f)||X(s,B,t,n,i,a,r,c,o+1,p,f);else if(_)if(g)S=X(s,M,t,n,i,a,r,c,o+1,p,f);else{const P=Q.getPrimitive();P.copy(fe).applyMatrix4(t);const v=$(s),E=j(s,h);F(v,d,ht),F(E,d,mt);const L=P.intersectsBox(ht),I=P.intersectsBox(mt);S=L&&X(M,v,n,t,i,r,a,o,c+1,P,!f)||I&&X(M,E,n,t,i,r,a,o,c+1,P,!f),Q.releasePrimitive(P)}else if(C)if(g)S=X(s,B,t,n,i,a,r,c,o+1,p,f);else{const P=Q.getPrimitive();P.copy(ue).applyMatrix4(t);const v=$(s),E=j(s,h);F(v,d,ht),F(E,d,mt);const L=P.intersectsBox(ht),I=P.intersectsBox(mt);S=L&&X(B,v,n,t,i,r,a,o,c+1,P,!f)||I&&X(B,E,n,t,i,r,a,o,c+1,P,!f),Q.releasePrimitive(P)}}return S}const Zt=new V,We=new N;class ee{static serialize(e,t={}){t={cloneBuffers:!0,...t};const n=e.geometry,i=e._roots,a=e._indirectBuffer,r=n.getIndex();let c;return t.cloneBuffers?c={roots:i.map(o=>o.slice()),index:r.array.slice(),indirectBuffer:a?a.slice():null}:c={roots:i,index:r.array,indirectBuffer:a},c}static deserialize(e,t,n={}){n={setIndex:!0,indirect:!!e.indirectBuffer,...n};const{index:i,roots:a,indirectBuffer:r}=e,c=new ee(t,{...n,[ie]:!0});if(c._roots=a,c._indirectBuffer=r||null,n.setIndex){const o=t.getIndex();if(o===null){const p=new xt(e.index,1,!1);t.setIndex(p)}else o.array!==i&&(o.array.set(i),o.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(e,t={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({strategy:Je,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[ie]:!1},t),t.useSharedArrayBuffer&&!Cs())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=e,this._roots=null,this._indirectBuffer=null,t[ie]||(Yn(this,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new N)));const{_indirectBuffer:n}=this;this.resolveTriangleIndex=t.indirect?i=>n[i]:i=>i}refit(e=null){return(this.indirect?bs:rs)(this,e)}traverse(e,t=0){const n=this._roots[t],i=new Uint32Array(n),a=new Uint16Array(n);r(0);function r(c,o=0){const p=c*2,f=a[p+15]===Qt;if(f){const u=i[c+6],l=a[p+14];e(o,f,new Float32Array(n,c*4,6),u,l)}else{const u=c+Kt/4,l=i[c+6],d=i[c+7];e(o,f,new Float32Array(n,c*4,6),d)||(r(u,o+1),r(l,o+1))}}}raycast(e,t=Se){const n=this._roots,i=this.geometry,a=[],r=t.isMaterial,c=Array.isArray(t),o=i.groups,p=r?t.side:t,f=this.indirect?gs:fs;for(let u=0,l=n.length;u<l;u++){const d=c?t[o[u].materialIndex].side:p,h=a.length;if(f(this,u,d,e,a),c){const A=o[u].materialIndex;for(let b=h,m=a.length;b<m;b++)a[b].face.materialIndex=A}}return a}raycastFirst(e,t=Se){const n=this._roots,i=this.geometry,a=t.isMaterial,r=Array.isArray(t);let c=null;const o=i.groups,p=a?t.side:t,f=this.indirect?Ts:ps;for(let u=0,l=n.length;u<l;u++){const d=r?t[o[u].materialIndex].side:p,h=f(this,u,d,e);h!=null&&(c==null||h.distance<c.distance)&&(c=h,r&&(h.face.materialIndex=o[u].materialIndex))}return c}intersectsGeometry(e,t){let n=!1;const i=this._roots,a=this.indirect?Bs:ds;for(let r=0,c=i.length;r<c&&(n=a(this,r,e,t),!n);r++);return n}shapecast(e){const t=H.getPrimitive(),n=this.indirect?ls:os;let{boundsTraverseOrder:i,intersectsBounds:a,intersectsRange:r,intersectsTriangle:c}=e;if(r&&c){const u=r;r=(l,d,h,A,b)=>u(l,d,h,A,b)?!0:n(l,d,this,c,h,A,t)}else r||(c?r=(u,l,d,h)=>n(u,l,this,c,d,h,t):r=(u,l,d)=>d);let o=!1,p=0;const f=this._roots;for(let u=0,l=f.length;u<l;u++){const d=f[u];if(o=Qn(this,u,a,r,i,p),o)break;p+=d.byteLength}return H.releasePrimitive(t),o}bvhcast(e,t,n){let{intersectsRanges:i,intersectsTriangles:a}=n;const r=H.getPrimitive(),c=this.geometry.index,o=this.geometry.attributes.position,p=this.indirect?h=>{const A=this.resolveTriangleIndex(h);R(r,A*3,c,o)}:h=>{R(r,h*3,c,o)},f=H.getPrimitive(),u=e.geometry.index,l=e.geometry.attributes.position,d=e.indirect?h=>{const A=e.resolveTriangleIndex(h);R(f,A*3,u,l)}:h=>{R(f,h*3,u,l)};if(a){const h=(A,b,m,x,y,w,g,T)=>{for(let S=m,M=m+x;S<M;S++){d(S),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let B=A,_=A+b;B<_;B++)if(p(B),r.needsUpdate=!0,a(r,f,B,S,y,w,g,T))return!0}return!1};if(i){const A=i;i=function(b,m,x,y,w,g,T,S){return A(b,m,x,y,w,g,T,S)?!0:h(b,m,x,y,w,g,T,S)}}else i=h}return zs(this,e,t,i)}intersectsBox(e,t){return Zt.set(e.min,e.max,t),Zt.needsUpdate=!0,this.shapecast({intersectsBounds:n=>Zt.intersectsBox(n),intersectsTriangle:n=>Zt.intersectsTriangle(n)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t,n={},i={},a=0,r=1/0){return(this.indirect?vs:ws)(this,e,t,n,i,a,r)}closestPointToPoint(e,t={},n=0,i=1/0){return ts(this,e,t,n,i)}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(n=>{F(0,new Float32Array(n),We),e.union(We)}),e}}const $e=new N;class Es extends un{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(e,t,n=10,i=0){super(),this.material=t,this.geometry=new ot,this.name="MeshBVHRootVisualizer",this.depth=n,this.displayParents=!1,this.mesh=e,this.displayEdges=!0,this._group=i}raycast(){}update(){const e=this.geometry,t=this.mesh.geometry.boundsTree,n=this._group;if(e.dispose(),this.visible=!1,t){const i=this.depth-1,a=this.displayParents;let r=0;t.traverse((l,d)=>{if(l===i||d)return r++,!0;a&&r++},n);let c=0;const o=new Float32Array(8*3*r);t.traverse((l,d,h)=>{const A=l===i||d;if(A||a){F(0,h,$e);const{min:b,max:m}=$e;for(let x=-1;x<=1;x+=2){const y=x<0?b.x:m.x;for(let w=-1;w<=1;w+=2){const g=w<0?b.y:m.y;for(let T=-1;T<=1;T+=2){const S=T<0?b.z:m.z;o[c+0]=y,o[c+1]=g,o[c+2]=S,c+=3}}}return A}},n);let p,f;this.displayEdges?f=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):f=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),o.length>65535?p=new Uint32Array(f.length*r):p=new Uint16Array(f.length*r);const u=f.length;for(let l=0;l<r;l++){const d=l*8,h=l*u;for(let A=0;A<u;A++)p[h+A]=d+f[A]}e.setIndex(new xt(p,1,!1)),e.setAttribute("position",new xt(o,3,!1)),this.visible=!0}}}class Me extends Ke{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(e){this.edgeMaterial.opacity=e,this.meshMaterial.opacity=e}constructor(e,t=10){super(),this.name="MeshBVHVisualizer",this.depth=t,this.mesh=e,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const n=new ln({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),i=new fn({color:65416,transparent:!0,opacity:.3,depthWrite:!1});i.color=n.color,this.edgeMaterial=n,this.meshMaterial=i,this.update()}update(){const e=this.mesh.geometry.boundsTree,t=e?e._roots.length:0;for(;this._roots.length>t;){const n=this._roots.pop();n.geometry.dispose(),this.remove(n)}for(let n=0;n<t;n++){if(n>=this._roots.length){const a=new Es(this.mesh,this.edgeMaterial,this.depth,n);this.add(a),this._roots.push(a)}const i=this._roots[n];i.depth=this.depth,i.mesh=this.mesh,i.displayParents=this.displayParents,i.displayEdges=this.displayEdges,i.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,i.update()}}updateMatrixWorld(...e){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...e)}copy(e){this.depth=e.depth,this.mesh=e.mesh}clone(){return new Me(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].geometry.dispose()}}function Ls(s){return this.boundsTree=new ee(this,s),this.boundsTree}function Us(){this.boundsTree=null}const nt=new z,st=new z,it=new z,je=new Te,Gt=new z,de=new z,Xe=new Te,Ye=new Te,Ot=new G,Ze=new G;function zt(s,e){if(!s&&!e)return;const t=s.count===e.count,n=s.normalized===e.normalized,i=s.array.constructor===e.array.constructor,a=s.itemSize===e.itemSize;if(!t||!n||!i||!a)throw new Error}function Lt(s,e=null){const t=s.array.constructor,n=s.normalized,i=s.itemSize,a=e===null?s.count:e;return new xt(new t(i*a),i,n)}function nn(s,e,t=0){if(s.isInterleavedBufferAttribute){const n=s.itemSize;for(let i=0,a=s.count;i<a;i++){const r=i+t;e.setX(r,s.getX(i)),n>=2&&e.setY(r,s.getY(i)),n>=3&&e.setZ(r,s.getZ(i)),n>=4&&e.setW(r,s.getW(i))}}else{const n=e.array,i=n.constructor,a=n.BYTES_PER_ELEMENT*s.itemSize*t;new i(n.buffer,a,s.array.length).set(s.array)}}function Fs(s,e,t){const n=s.elements,i=e.elements;for(let a=0,r=i.length;a<r;a++)n[a]+=i[a]*t}function Ge(s,e,t){const n=s.skeleton,i=s.geometry,a=n.bones,r=n.boneInverses;Xe.fromBufferAttribute(i.attributes.skinIndex,e),Ye.fromBufferAttribute(i.attributes.skinWeight,e),Ot.elements.fill(0);for(let c=0;c<4;c++){const o=Ye.getComponent(c);if(o!==0){const p=Xe.getComponent(c);Ze.multiplyMatrices(a[p].matrixWorld,r[p]),Fs(Ot,Ze,o)}}return Ot.multiply(s.bindMatrix).premultiply(s.bindMatrixInverse),t.transformDirection(Ot),t}function he(s,e,t,n,i){Gt.set(0,0,0);for(let a=0,r=s.length;a<r;a++){const c=e[a],o=s[a];c!==0&&(de.fromBufferAttribute(o,n),t?Gt.addScaledVector(de,c):Gt.addScaledVector(de.sub(i),c))}i.add(Gt)}function Is(s,e={useGroups:!1,updateIndex:!1,skipAttributes:[]},t=new ot){const n=s[0].index!==null,{useGroups:i=!1,updateIndex:a=!1,skipAttributes:r=[]}=e,c=new Set(Object.keys(s[0].attributes)),o={};let p=0;t.clearGroups();for(let f=0;f<s.length;++f){const u=s[f];let l=0;if(n!==(u.index!==null))throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");for(const d in u.attributes){if(!c.has(d))throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "'+d+'" attribute exists among all geometries, or in none of them.');o[d]===void 0&&(o[d]=[]),o[d].push(u.attributes[d]),l++}if(l!==c.size)throw new Error("StaticGeometryGenerator: Make sure all geometries have the same number of attributes.");if(i){let d;if(n)d=u.index.count;else if(u.attributes.position!==void 0)d=u.attributes.position.count;else throw new Error("StaticGeometryGenerator: The geometry must have either an index or a position attribute");t.addGroup(p,d,f),p+=d}}if(n){let f=!1;if(!t.index){let u=0;for(let l=0;l<s.length;++l)u+=s[l].index.count;t.setIndex(new xt(new Uint32Array(u),1,!1)),f=!0}if(a||f){const u=t.index;let l=0,d=0;for(let h=0;h<s.length;++h){const A=s[h],b=A.index;if(r[h]!==!0)for(let m=0;m<b.count;++m)u.setX(l,b.getX(m)+d),l++;d+=A.attributes.position.count}}}for(const f in o){const u=o[f];if(!(f in t.attributes)){let h=0;for(const A in u)h+=u[A].count;t.setAttribute(f,Lt(o[f][0],h))}const l=t.attributes[f];let d=0;for(let h=0,A=u.length;h<A;h++){const b=u[h];r[h]!==!0&&nn(b,l,d),d+=b.count}}return t}function Rs(s,e){if(s===null||e===null)return s===e;if(s.length!==e.length)return!1;for(let t=0,n=s.length;t<n;t++)if(s[t]!==e[t])return!1;return!0}class Vs{constructor(e){this.matrixWorld=new G,this.geometryHash=null,this.boneMatrices=null,this.primitiveCount=-1,this.mesh=e,this.update()}update(){const e=this.mesh,t=e.geometry,n=e.skeleton,i=(t.index?t.index.count:t.attributes.position.count)/3;if(this.matrixWorld.copy(e.matrixWorld),this.geometryHash=t.attributes.position.version,this.primitiveCount=i,n){n.boneTexture||n.computeBoneTexture(),n.update();const a=n.boneMatrices;!this.boneMatrices||this.boneMatrices.length!==a.length?this.boneMatrices=a.slice():this.boneMatrices.set(a)}else this.boneMatrices=null}didChange(){const e=this.mesh,t=e.geometry,n=(t.index?t.index.count:t.attributes.position.count)/3;return!(this.matrixWorld.equals(e.matrixWorld)&&this.geometryHash===t.attributes.position.version&&Rs(e.skeleton&&e.skeleton.boneMatrices||null,this.boneMatrices)&&this.primitiveCount===n)}}class Ds{constructor(e){Array.isArray(e)||(e=[e]);const t=[];e.forEach(n=>{n.traverseVisible(i=>{i.isMesh&&t.push(i)})}),this.meshes=t,this.useGroups=!0,this.applyWorldTransforms=!0,this.attributes=["position","normal","color","tangent","uv","uv2"],this._intermediateGeometry=new Array(t.length).fill().map(()=>new ot),this._diffMap=new WeakMap}getMaterials(){const e=[];return this.meshes.forEach(t=>{Array.isArray(t.material)?e.push(...t.material):e.push(t.material)}),e}generate(e=new ot){let t=[];const{meshes:n,useGroups:i,_intermediateGeometry:a,_diffMap:r}=this;for(let c=0,o=n.length;c<o;c++){const p=n[c],f=a[c],u=r.get(p);!u||u.didChange(p)?(this._convertToStaticGeometry(p,f),t.push(!1),u?u.update():r.set(p,new Vs(p))):t.push(!0)}Is(a,{useGroups:i,skipAttributes:t},e);for(const c in e.attributes)e.attributes[c].needsUpdate=!0;return e}_convertToStaticGeometry(e,t=new ot){const n=e.geometry,i=this.applyWorldTransforms,a=this.attributes.includes("normal"),r=this.attributes.includes("tangent"),c=n.attributes,o=t.attributes;t.index||(t.index=n.index),o.position||t.setAttribute("position",Lt(c.position)),a&&!o.normal&&c.normal&&t.setAttribute("normal",Lt(c.normal)),r&&!o.tangent&&c.tangent&&t.setAttribute("tangent",Lt(c.tangent)),zt(n.index,t.index),zt(c.position,o.position),a&&zt(c.normal,o.normal),r&&zt(c.tangent,o.tangent);const p=c.position,f=a?c.normal:null,u=r?c.tangent:null,l=n.morphAttributes.position,d=n.morphAttributes.normal,h=n.morphAttributes.tangent,A=n.morphTargetsRelative,b=e.morphTargetInfluences,m=new pn;m.getNormalMatrix(e.matrixWorld);for(let x=0,y=c.position.count;x<y;x++)nt.fromBufferAttribute(p,x),f&&st.fromBufferAttribute(f,x),u&&(je.fromBufferAttribute(u,x),it.fromBufferAttribute(u,x)),b&&(l&&he(l,b,A,x,nt),d&&he(d,b,A,x,st),h&&he(h,b,A,x,it)),e.isSkinnedMesh&&(e.applyBoneTransform(x,nt),f&&Ge(e,x,st),u&&Ge(e,x,it)),i&&nt.applyMatrix4(e.matrixWorld),o.position.setXYZ(x,nt.x,nt.y,nt.z),f&&(i&&st.applyNormalMatrix(m),o.normal.setXYZ(x,st.x,st.y,st.z)),u&&(i&&it.transformDirection(e.matrixWorld),o.tangent.setXYZW(x,it.x,it.y,it.z,je.w));for(const x in this.attributes){const y=this.attributes[x];y==="position"||y==="tangent"||y==="normal"||!(y in c)||(o[y]||t.setAttribute(y,Lt(c[y])),zt(c[y],o[y]),nn(c[y],o[y]))}return t}}var ks=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Ns(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}var sn={exports:{}};(function(s,e){(function(t,n){s.exports=n()})(ks,function(){var t=function(){function n(d){return r.appendChild(d.dom),d}function i(d){for(var h=0;h<r.children.length;h++)r.children[h].style.display=h===d?"block":"none";a=d}var a=0,r=document.createElement("div");r.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",r.addEventListener("click",function(d){d.preventDefault(),i(++a%r.children.length)},!1);var c=(performance||Date).now(),o=c,p=0,f=n(new t.Panel("FPS","#0ff","#002")),u=n(new t.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var l=n(new t.Panel("MB","#f08","#201"));return i(0),{REVISION:16,dom:r,addPanel:n,showPanel:i,begin:function(){c=(performance||Date).now()},end:function(){p++;var d=(performance||Date).now();if(u.update(d-c,200),d>o+1e3&&(f.update(1e3*p/(d-o),100),o=d,p=0,l)){var h=performance.memory;l.update(h.usedJSHeapSize/1048576,h.jsHeapSizeLimit/1048576)}return d},update:function(){c=this.end()},domElement:r,setMode:i}};return t.Panel=function(n,i,a){var r=1/0,c=0,o=Math.round,p=o(window.devicePixelRatio||1),f=80*p,u=48*p,l=3*p,d=2*p,h=3*p,A=15*p,b=74*p,m=30*p,x=document.createElement("canvas");x.width=f,x.height=u,x.style.cssText="width:80px;height:48px";var y=x.getContext("2d");return y.font="bold "+9*p+"px Helvetica,Arial,sans-serif",y.textBaseline="top",y.fillStyle=a,y.fillRect(0,0,f,u),y.fillStyle=i,y.fillText(n,l,d),y.fillRect(h,A,b,m),y.fillStyle=a,y.globalAlpha=.9,y.fillRect(h,A,b,m),{dom:x,update:function(w,g){r=Math.min(r,w),c=Math.max(c,w),y.fillStyle=a,y.globalAlpha=1,y.fillRect(0,0,f,A),y.fillStyle=i,y.fillText(o(w)+" "+n+" ("+o(r)+"-"+o(c)+")",l,d),y.drawImage(x,h+p,A,b-p,m,h,A,b-p,m),y.fillRect(h+b-p,A,p,m),y.fillStyle=a,y.globalAlpha=.9,y.fillRect(h+b-p,A,p,o((1-w/g)*m))}}},t})})(sn);var qs=sn.exports;const Hs=Ns(qs),Ys=Pn({__name:"ThreeMeshBvhDemo",setup(s){const e=Mn();let t,n,i,a,r,c,o,p,f;ot.prototype.computeBoundsTree=Ls,ot.prototype.disposeBoundsTree=Us;const u=new z,l=()=>{i=new dn,n=new hn(70,window.innerWidth/window.innerHeight,.1,100),n.position.set(10,10,-10);const w=new mn(5);i.add(w),t=new yn({antialias:!0}),t.setPixelRatio(window.devicePixelRatio),t.setSize(window.innerWidth,window.innerHeight),t.setClearColor(1251612,1),t.shadowMap.enabled=!0,t.shadowMap.type=xn,t.outputColorSpace=wn,e.value.appendChild(t.domElement),a=new Bn(n,t.domElement),f=new Hs,document.body.appendChild(f.dom),A(),h(),d(),m()},d=()=>{r=new ne(new Cn(1,2,1,10,.5),new _e),r.geometry.translate(0,-.5,0),r.capsuleInfo={radius:.5,segment:new Z(new z,new z(0,-1,0))},r.castShadow=!0,r.receiveShadow=!0,r.material.shadowSide=2,i.add(r),b()},h=()=>{new An().load("./model/mesh-bvh/scene.gltf",y=>{const w=y.scene;w.scale.setScalar(.01);const g=new N;g.setFromObject(w),g.getCenter(w.position).negate(),w.updateMatrixWorld(!0),console.log(w,"gltfScene");const T={};w.traverse(B=>{if(!(/Boss/.test(B.name)||/Enemie/.test(B.name)||/Shield/.test(B.name)||/Sword/.test(B.name)||/Character/.test(B.name)||/Gate/.test(B.name)||/Cube/.test(B.name)||B.material&&B.material.color.r===1)&&B.isMesh){const _=B.material.color.getHex();T[_]=T[_]||[],T[_].push(B)}}),c=new Ke;for(const B in T){const _=T[B],C=[];if(_.forEach(P=>{if(P.material.emissive.r!==0)c.attach(P);else{const v=P.geometry.clone();v.applyMatrix4(P.matrixWorld),C.push(v)}}),C.length){const P=Tn(C),v=new ne(P,new _e({color:parseInt(B),shadowSide:2}));v.castShadow=!0,v.receiveShadow=!0,v.material.shadowSide=2,c.add(v)}}const S=new Ds(c);S.attributes=["position"];const M=S.generate();M.boundsTree=new ee(M),o=new ne(M),o.material.wireframe=!0,o.material.opacity=.5,o.material.transparent=!0,o.visible=!1,p=new Me(o,10),i.add(p),i.add(o),i.add(c)})},A=()=>{const y=new bn(16777215,1);y.position.set(1,1.5,1).multiplyScalar(50),y.shadow.mapSize.setScalar(2048),y.shadow.bias=-1e-4,y.shadow.normalBias=.05,y.castShadow=!0;const w=y.shadow.camera;w.bottom=w.left=-30,w.top=30,w.right=45,i.add(y),i.add(new gn(16777215,2241348,.4))},b=()=>{u.set(0,0,0),r.position.set(15.75,-3,30),n.position.sub(a.target),a.target.copy(r.position),n.position.add(r.position),a.update()},m=()=>{f.update(),t.render(i,n),requestAnimationFrame(m)},x=()=>{window.addEventListener("resize",function(){n.aspect=window.innerWidth/window.innerHeight,n.updateProjectionMatrix(),t.setSize(window.innerWidth,window.innerHeight)},!1)};return Sn(()=>{l(),x()}),(y,w)=>(vn(),_n("div",{ref_key:"threeRef",ref:e},null,512))}});export{Ys as default};
